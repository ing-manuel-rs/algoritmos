# **Notaci√≥n asint√≥tica big O**

La notaci√≥n asint√≥tica describe c√≥mo crece el tiempo o espacio requerido por un algoritmo a medida que aumenta el tama√±o de la entrada (denotado como `n`).
No mide tiempo real, sino crecimiento relativo: ¬øC√≥mo escala el algoritmo?



## ¬øPor qu√© es importante?

- Te permite comparar algoritmos objetivamente
- Te ayuda a detectar cuellos de botella
- Es vital para entrevistas t√©cnicas, optimizaci√≥n y dise√±o de sistemas



## Tipos principales de notaci√≥n

| Notaci√≥n      | Significado                                           |
| ------------- | ----------------------------------------------------- |
| **O (Big-O)** | Cota **superior**: el peor caso posible               |
| **Œ© (Omega)** | Cota **inferior**: el mejor caso posible              |
| **Œò (Theta)** | Cota **exacta**: cuando mejor y peor caso son iguales |

En este curso nos enfocaremos principalmente en Big-O (ùë∂) porque representa el peor escenario, el m√°s relevante para sistemas reales.



## Tabla de complejidades comunes

|Notaci√≥n|Nombre|Ejemplo t√≠pico|
|---|---|---|
|O(1)|Tiempo constante|Acceso a un elemento en un array|
|O(log n)|Tiempo logar√≠tmico|B√∫squeda binaria|
|O(n)|Tiempo lineal|Recorrer un array|
|O(n log n)|Tiempo log-linear|Merge Sort, Quick Sort|
|O(n¬≤)|Tiempo cuadr√°tico|Burbujas, selecci√≥n, anidado|
|O(2‚Åø)|Tiempo exponencial|Recursi√≥n sin poda, backtracking|
|O(n!)|Tiempo factorial|Permutaciones (fuerza bruta)|



## Ejemplos de cada complejidad

#### O(1) ‚Äì Constante
```js
function obtenerPrimero(arr) {
  return arr[0];
}
```
Sin importar el tama√±o de `arr`, solo hace 1 operaci√≥n.

#### O(n) ‚Äì Lineal
```js
function imprimirTodos(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
```
Hace 1 operaci√≥n por cada elemento.

## O(n¬≤) ‚Äì Cuadr√°tica
```js
function compararTodos(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr[i], arr[j]);
    }
  }
}
```
El n√∫mero de operaciones crece exponencialmente al cuadrado de `n`.

## O(log n) ‚Äì Logar√≠tmica
```js
function busquedaBinaria(arr, objetivo) {
  let izquierda = 0, derecha = arr.length - 1;
  while (izquierda <= derecha) {
    const medio = Math.floor((izquierda + derecha) / 2);
    if (arr[medio] === objetivo) return medio;
    if (arr[medio] < objetivo) izquierda = medio + 1;
    else derecha = medio - 1;
  }
  return -1;
}
```
El array se divide a la mitad en cada paso ‚áí log‚ÇÇ(n) pasos.

## O(2‚Åø) ‚Äì Exponencial
```js
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```
El √°rbol de llamadas se duplica recursivamente.



## Gr√°fico comparativo (crecimiento con `n`)

```bash
n:   1   2   4   8   16

O(1):   1   1   1   1   1
O(log n): 0  1   2   3   4
O(n):    1   2   4   8   16
O(n log n): 0  2   8  24   64
O(n¬≤):   1   4  16  64  256
O(2‚Åø):   2   4  16 256 65536
```
Cuanto m√°s grande es `n`, m√°s dr√°stica es la diferencia.



## C√≥mo identificar la complejidad de un algoritmo

#### Consejos pr√°cticos

| C√≥digo                                   | Complejidad |
| ---------------------------------------- | ----------- |
| `for` simple                             | O(n)        |
| `for` anidado                            | O(n¬≤)       |
| B√∫squeda binaria / divide a la mitad     | O(log n)    |
| Bucle que reduce `n` a la mitad          | O(log n)    |
| Funci√≥n recursiva con m√∫ltiples llamadas | O(2‚Åø)       |



## ¬øY el espacio?

Adem√°s del tiempo, tambi√©n analizamos la complejidad espacial: ¬øcu√°nta memoria necesita el algoritmo?

Ejemplo:
```js
function duplicarArray(arr) {
  let nuevo = [];
  for (let i = 0; i < arr.length; i++) {
    nuevo.push(arr[i] * 2);
  }
  return nuevo;
}
```
- Tiempo: O(n) 
- Espacio: O(n) (nuevo array)

**Ejemplo comparativo**

O(n¬≤): B√∫squeda de pares repetidos
```js
function tieneDuplicados(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) return true;
    }
  }
  return false;
}
```

O(n): Usando Set
```js
function tieneDuplicados(arr) {
  const set = new Set();
  for (let num of arr) {
    if (set.has(num)) return true;
    set.add(num);
  }
  return false;
}
```
Misma funcionalidad, pero 10 veces m√°s r√°pido en grandes entradas.



