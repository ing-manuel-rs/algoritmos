# **Ordenamiento merge sort**

Merge Sort es un algoritmo de ordenamiento basado en el principio de divide y vencer√°s:
1. **Divide** el arreglo en dos mitades.
2. Ordena **recursivamente** cada mitad.
3. **Combina (merge)** las dos mitades ordenadas en una sola lista final.
La clave de Merge Sort es que la combinaci√≥n (merge) se hace de forma ordenada.



## ¬øC√≥mo funciona?

Supongamos que tenemos el arreglo `[6, 2, 9, 4]`.
1. Lo dividimos en dos partes: `[6, 2]` y `[9, 4]`
2. Dividimos de nuevo: `[6] [2]` y `[9] [4]`
3. Ordenamos y combinamos: `[2, 6]` y `[4, 9]`
4. Finalmente, combinamos ambas: `[2, 4, 6, 9]`



## Implementaci√≥n en JavaScript

#### Versi√≥n recursiva cl√°sica
```js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const medio = Math.floor(arr.length / 2);
  const izquierda = mergeSort(arr.slice(0, medio));
  const derecha = mergeSort(arr.slice(medio));

  return merge(izquierda, derecha);
}

function merge(izquierda, derecha) {
  const resultado = [];
  let i = 0, j = 0;

  while (i < izquierda.length && j < derecha.length) {
    if (izquierda[i] < derecha[j]) {
      resultado.push(izquierda[i]);
      i++;
    } else {
      resultado.push(derecha[j]);
      j++;
    }
  }

  // Agregar elementos restantes
  return resultado.concat(izquierda.slice(i)).concat(derecha.slice(j));
}
```

### üß© Explicaci√≥n del `merge()`

- Compara los elementos actuales de los dos subarreglos (`izquierda` y `derecha`)
- Agrega el menor al resultado
- Avanza el √≠ndice en el subarreglo correspondiente
- Cuando uno se termina, se agregan los elementos restantes del otro



## Complejidad algor√≠tmica

| Caso                  | Comparaciones | Complejidad               |
| --------------------- | ------------- | ------------------------- |
| **Mejor caso**        | n log n       | O(n log n) ‚úÖ              |
| **Peor caso**         | n log n       | O(n log n) ‚úÖ              |
| **Promedio**          | n log n       | O(n log n) ‚úÖ              |
| **Espacio adicional** | O(n)          | ‚ùå (usa arrays temporales) |
| **Estabilidad**       | ‚úîÔ∏è            |                           |



## Visualizaci√≥n paso a paso

Ordenar `[8, 4, 2, 9]` con Merge Sort:
```js
‚Üí divide: [8, 4] [2, 9]
‚Üí divide: [8] [4] ‚Üí merge: [4, 8]
‚Üí divide: [2] [9] ‚Üí merge: [2, 9]
‚Üí merge final: [2, 4, 8, 9]
```



## Ventajas

| Ventaja                                | Detalles                                |
| -------------------------------------- | --------------------------------------- |
| Estable                                | No cambia el orden de elementos iguales |
| Tiempo garantizado O(n log n)          | Incluso en el peor caso                 |
| Ideal para listas grandes              | Mejor que Bubble/Selection/Insertion    |
| Se adapta bien a estructuras de listas | (Linked Lists)                          |



## Desventajas

|Desventaja|Detalles|
|---|---|
|Uso de espacio adicional|Crea nuevos arreglos (no in-place)|
|M√°s dif√≠cil de implementar que b√°sicos|Requiere recursividad + mezcla ordenada|
|No ideal para datos muy grandes en memoria limitada|Por su uso de espacio auxiliar|